xformla = ~ AGE + NCHILD + EDUC + RACE + MARST,
control_group = "notyettreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
table(duplicated(df_final$CPSID))
table(duplicated(df1$CPSID))
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
idname  = "obs_id",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST,
control_group = "notyettreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
df1$obs_id <- 1:nrow(df1)
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
idname  = "obs_id",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST,
control_group = "notyettreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
summary(att_cs)
summary(agg_cs)
agg_cs <- aggte(att_cs, type = "group")
summary(agg_cs)
agg_dyn <- aggte(att_cs, type = "dynamic")
summary(agg_dyn)
ggdid(agg_dyn)
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST + UNEMPLOYMENTRATE + median_weekly_wage,
control_group = "notyettreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST + UNEMPLOYMENTRATE + median_weekly_wage,
control_group = "nevertreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
unique(df_final$STATE[is.na(df_final$treat_start_year)])
unique(df1$STATE[is.na(df_final$treat_start_year)])
unique(df1$STATE[is.na(df1$treat_start_year)])
df1$treat_start_year[is.na(df1$treat_start_year)] <- 0
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST + UNEMPLOYMENTRATE + median_weekly_wage,
control_group = "nevertreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST + UNEMPLOYMENTRATE,
control_group = "nevertreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST,
control_group = "nevertreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
att_cs <- att_gt(
yname   = "birth_lastyear",
tname   = "YEAR",
gname   = "treat_start_year",
xformla = ~ AGE + NCHILD + EDUC + RACE + MARST,
control_group = "nevertreated",
weightsname = "ASECWT",
data    = df1,
panel = F,
clustervars = "STATEFIP"
)
agg_dyn <- aggte(att_cs, type = "dynamic")
summary(agg_dyn)
ggdid(agg_dyn)
# Importing relevant packages
library(tidyverse)
library(lubridate)
# Importing Dataset
rawPolicyData <- read_csv("../data/search-results.csv", show_col_types = FALSE)
head(rawPolicyData)
# Handling of Policy's Start/End dates
clean <- rawPolicyData %>%
mutate(
# If the end date of policy is outside of our sample range, we set it to last possible date
Policy_Date_End = if_else(Policy_Date_End == "Ongoing", "2011-12-31", Policy_Date_End),
FamCapDate = na_if(FamCapDate, "n.a."),
Policy_Date_Begin = ymd(Policy_Date_Begin),
Policy_Date_End   = ymd(Policy_Date_End),
FamCapDate        = mdy(FamCapDate) # FamCapDate is in the format of m/d/y
)
state_policy <- clean %>%
group_by(State) %>%
summarise(
ever_treated     = as.integer(any(FamCapExist == "Yes")), # ever_treated tells us if the state was ever treated at any point
treat_start_year = min(coalesce(year(FamCapDate), year(Policy_Date_Begin))[FamCapExist == "Yes"], na.rm = TRUE),
repeal_year = max(year(Policy_Date_End)[FamCapExist == "Yes"], na.rm = TRUE),
# Coalesce is because there exists scenarios where FamCapDate is somehow before Policy_Date_Begin in the dataset
.groups = "drop" # Ungroup after
)%>%
mutate(
# this is so that treat_start_year/repeal_year is set to N.A. for those that weren't ever treated
treat_start_year = if_else(is.infinite(treat_start_year), NA_real_, treat_start_year),
repeal_year      = if_else(is.infinite(repeal_year), NA_real_, repeal_year)
)
table(state_policy$ever_treated) # 24 treated, 30 never treated, but there's some that should be removed later on
# Next, we make it into panel data, aka making an entry for every (State, year) pair
t_min <- 1982; t_max <- 2011
state_year <- expand_grid(State = unique(state_policy$State),
year = t_min:t_max) %>%
left_join(state_policy, by = "State") %>%
mutate(
treated = if_else(!is.na(treat_start_year) & year >= treat_start_year, 1L, 0L),
treated = if_else(!is.na(repeal_year) & year > repeal_year, 0L, treated)
)
state_year
# Save as RDS
saveRDS(state_year, "../cleaned_data/policyImplementation.rds")
# Importing relevant packages
library(tidyverse)
library(lubridate)
# Importing Dataset
rawPolicyData <- read_csv("../data/search-results.csv", show_col_types = FALSE)
head(rawPolicyData)
# Handling of Policy's Start/End dates
clean <- rawPolicyData %>%
mutate(
# If the end date of policy is outside of our sample range, we set it to last possible date
Policy_Date_End = if_else(Policy_Date_End == "Ongoing", "2011-12-31", Policy_Date_End),
FamCapDate = na_if(FamCapDate, "n.a."),
Policy_Date_Begin = ymd(Policy_Date_Begin),
Policy_Date_End   = ymd(Policy_Date_End),
FamCapDate        = mdy(FamCapDate) # FamCapDate is in the format of m/d/y
)
state_policy <- clean %>%
group_by(State) %>%
summarise(
ever_treated     = as.integer(any(FamCapExist == "Yes")), # ever_treated tells us if the state was ever treated at any point
treat_start_year = min(coalesce(year(FamCapDate), year(Policy_Date_Begin))[FamCapExist == "Yes"], na.rm = TRUE),
repeal_year = max(year(Policy_Date_End)[FamCapExist == "Yes"], na.rm = TRUE),
# Coalesce is because there exists scenarios where FamCapDate is somehow before Policy_Date_Begin in the dataset
.groups = "drop" # Ungroup after
)%>%
mutate(
# this is so that treat_start_year/repeal_year is set to N.A. for those that weren't ever treated
treat_start_year = if_else(is.infinite(treat_start_year), NA_real_, treat_start_year),
repeal_year      = if_else(is.infinite(repeal_year), NA_real_, repeal_year)
)
table(state_policy$ever_treated) # 24 treated, 30 never treated, but there's some that should be removed later on
# Next, we make it into panel data, aka making an entry for every (State, year) pair
t_min <- 1982; t_max <- 2011
state_year <- expand_grid(State = unique(state_policy$State),
year = t_min:t_max) %>%
left_join(state_policy, by = "State") %>%
mutate(
treated = if_else(!is.na(treat_start_year) & year >= treat_start_year, 1L, 0L),
treated = if_else(!is.na(repeal_year) & year > repeal_year, 0L, treated)
)
state_year
View(state_year)
# Import libraries
library(readr)
library(dplyr)
library(lubridate)
# Import Data
rawCPS <- read_csv("../data/cps_00004.csv", show_col_types = FALSE)
head(rawCPS)
# Filtering for
# 1. Unmarried (Not 1, 2)
# 2. women (2)
# 3. aged between 18 and 45
# 4. with at most a high school degree (<= 73)
CPS1 <- rawCPS %>%
filter(SEX == 2, AGE >= 18, AGE <= 45, EDUC <= 73, (MARST %in% c(3, 4, 5, 6, 7)))
colSums(is.na(CPS1))
summary(CPS1)
CPS1 %>%
group_by(YEAR) %>%
summarise(
n_total = n(),
n_na = sum(is.na(UHRSWORKT)),
share_na = mean(is.na(UHRSWORKT))
)
CPS1 %>%
group_by(YEAR) %>%
summarise(
n_total = n(),
n_na = sum(is.na(UHRSWORKT)),
share_na = mean(is.na(UHRSWORKT))
)
print(n = 100)
# Checking which years contain the NA's, which are outside of our sample range, so not a big issue
print(CPS1 %>%
group_by(YEAR) %>%
summarise(
n_total = n(),
n_na = sum(is.na(UHRSWORKT)),
share_na = mean(is.na(UHRSWORKT))
))
# Checking which years contain the NA's, which are outside of our sample range, so not a big issue
print(CPS1 %>%
group_by(YEAR) %>%
summarise(
n_total = n(),
n_na = sum(is.na(UHRSWORKT)),
share_na = mean(is.na(UHRSWORKT))
), n = 100)
# Import libraries
library(readr)
library(dplyr)
library(lubridate)
# Import Data
rawCPS <- read_csv("../data/cps_00004.csv", show_col_types = FALSE)
head(rawCPS)
# Filtering for
# 1. Unmarried (Not 1, 2)
# 2. women (2)
# 3. aged between 18 and 45
# 4. with at most a high school degree (<= 73)
CPS1 <- rawCPS %>%
filter(SEX == 2, AGE >= 18, AGE <= 45, EDUC <= 73, (MARST %in% c(3, 4, 5, 6, 7)))
# Checking for NA's
colSums(is.na(CPS1)) # NA's present in UHRSWORKT
# Checking which years contain the NA's, which are outside of our sample range (pre 1994), so not a big issue
print(CPS1 %>%
group_by(YEAR) %>%
summarise(
n_total = n(),
n_na = sum(is.na(UHRSWORKT)),
share_na = mean(is.na(UHRSWORKT))
), n = 100)
# Checking if any weird values/outliers, which there are
summary(CPS1)
# Cleaning "Total hours worked last week" (according to codebook)
CPS2 <- CPS1 %>%
mutate(
UHRSWORKT = case_when(
UHRSWORKT == 997 ~ NA_real_,    # hours vary -> NA
UHRSWORKT == 999 ~ 0,            # not applicable means 0
TRUE ~ UHRSWORKT
)
)
# Creating outcome variable: "Employed" and "Fertility" (using whether youngest child <= 1yo)
CPS3 <- CPS2 %>%
mutate(
employed = ifelse(EMPSTAT %in% c(10, 12), 1, 0), # creating "employed" outcome indicator
birth_lastyear = ifelse(YNGCH <= 1, 1, 0) # creating "fertility" outcome indicator
)
table(CPS3$birth_lastyear)
table(CPS3$employed)
# Import libraries
library(readr)
library(dplyr)
library(lubridate)
# Import Data
rawCPS <- read_csv("../data/cps_00004.csv", show_col_types = FALSE)
head(rawCPS)
# Filtering for
# 1. Unmarried (Not 1, 2)
# 2. women (2)
# 3. aged between 18 and 45
# 4. with at most a high school degree (<= 73)
CPS1 <- rawCPS %>%
filter(SEX == 2, AGE >= 18, AGE <= 45, EDUC <= 73, (MARST %in% c(3, 4, 5, 6, 7)))
# Checking for NA's
colSums(is.na(CPS1)) # NA's present in UHRSWORKT
# Checking which years contain the NA's, which are outside of our sample range (pre 1994), so not a big issue
print(CPS1 %>%
group_by(YEAR) %>%
summarise(
n_total = n(),
n_na = sum(is.na(UHRSWORKT)),
share_na = mean(is.na(UHRSWORKT))
), n = 100)
# Checking if any weird values/outliers, which there are
summary(CPS1)
# Cleaning "Total hours worked last week" (according to codebook)
CPS2 <- CPS1 %>%
mutate(
UHRSWORKT = case_when(
UHRSWORKT == 997 ~ NA_real_,    # hours vary -> NA
UHRSWORKT == 999 ~ 0,            # not applicable means 0
TRUE ~ UHRSWORKT
)
)
# Creating outcome variable: "Employed" and "Fertility" (using whether youngest child <= 1yo)
CPS3 <- CPS2 %>%
mutate(
employed = ifelse(EMPSTAT %in% c(10, 12), 1, 0), # creating "employed" outcome indicator
birth_lastyear = ifelse(YNGCH <= 1, 1, 0) # creating "fertility" outcome indicator
)
table(CPS3$birth_lastyear)
table(CPS3$employed)
# Creating Race dummy variables
CPS4 <- CPS3 %>%
mutate(
black = if_else(RACE == 200, 1, 0),
white = if_else(RACE == 100, 1, 0),
other = if_else(!RACE %in% c(100, 200), 1, 0)
)
# Lastly, check for NA's again
colSums(is.na(CPS4))
# Import libraries
library(readr)
library(dplyr)
library(lubridate)
# Import Data
rawCPS <- read_csv("../data/cps_00004.csv", show_col_types = FALSE)
head(rawCPS)
# Filtering for
# 1. Unmarried (Not 1, 2)
# 2. women (2)
# 3. aged between 18 and 45
# 4. with at most a high school degree (<= 73)
CPS1 <- rawCPS %>%
filter(SEX == 2, AGE >= 18, AGE <= 45, EDUC <= 73, (MARST %in% c(3, 4, 5, 6, 7)))
# Checking for NA's
colSums(is.na(CPS1)) # NA's present in UHRSWORKT
# Checking which years contain the NA's, which are outside of our sample range (pre 1994), so not a big issue
print(CPS1 %>%
group_by(YEAR) %>%
summarise(
n_total = n(),
n_na = sum(is.na(UHRSWORKT)),
share_na = mean(is.na(UHRSWORKT))
), n = 100)
# Checking if any weird values/outliers, which there are
summary(CPS1)
# Cleaning "Total hours worked last week" (according to codebook)
CPS2 <- CPS1 %>%
mutate(
UHRSWORKT = case_when(
UHRSWORKT == 997 ~ NA_real_,    # hours vary -> NA
UHRSWORKT == 999 ~ 0,            # not applicable means 0
TRUE ~ UHRSWORKT
)
)
# Creating outcome variable: "Employed" and "Fertility" (using whether youngest child <= 1yo)
CPS3 <- CPS2 %>%
mutate(
employed = ifelse(EMPSTAT %in% c(10, 12), 1, 0), # creating "employed" outcome indicator
birth_lastyear = ifelse(YNGCH <= 1, 1, 0) # creating "fertility" outcome indicator
)
table(CPS3$birth_lastyear)
table(CPS3$employed)
# Creating Race dummy variables
CPS4 <- CPS3 %>%
mutate(
black = if_else(RACE == 200, 1, 0),
white = if_else(RACE == 100, 1, 0),
other = if_else(!RACE %in% c(100, 200), 1, 0)
)
# Lastly, check for NA's again
colSums(is.na(CPS4))
# Save as RDS
saveRDS(CPS4, "../cleaned_data/indivCPS.rds")
# Import libraries
library(tidyverse)
library(lubridate)
library(readxl)
library(Hmisc) # this one is for computing weighted median wages
##### Unemployment rate #####
# Import data
rawEmploymentData <- read_excel("../data/ststdnsadata.xlsx",
range = "A9:K31596",
col_names = c("STATEFIP", "STATE", "YEAR", "MONTH", "CNIP", "LABORFORCE", "PCT", "EMPLOYED", "EMPLOYMENTRATE", "UNEMPLOYED", "UNEMPLOYMENTRATE")
)
head(rawEmploymentData)
n_distinct(rawEmploymentData$STATEFIP)
unique(rawEmploymentData$STATEFIP)
# Keep only states
employmentData1 <- rawEmploymentData %>%
filter(!STATEFIP %in% c("037", "51000"))
n_distinct(employmentData1$STATEFIP)
# Aggregate monthly unemployment rates into annual
annualEmploymentData <- employmentData1 %>%
group_by(STATEFIP, STATE, YEAR) %>%
summarise(
UNEMPLOYMENTRATE = mean(UNEMPLOYMENTRATE, na.rm = TRUE),
) %>%
ungroup()
head(annualEmploymentData)
colSums(is.na(annualEmploymentData))
colSums(is.na(rawFemaleWage))
# Import libraries
library(tidyverse)
library(lubridate)
library(readxl)
library(Hmisc) # this one is for computing weighted median wages
##### Unemployment rate #####
# Import data
rawEmploymentData <- read_excel("../data/ststdnsadata.xlsx",
range = "A9:K31596",
col_names = c("STATEFIP", "STATE", "YEAR", "MONTH", "CNIP", "LABORFORCE", "PCT", "EMPLOYED", "EMPLOYMENTRATE", "UNEMPLOYED", "UNEMPLOYMENTRATE")
)
head(rawEmploymentData)
n_distinct(rawEmploymentData$STATEFIP)
unique(rawEmploymentData$STATEFIP)
# Keep only states
employmentData1 <- rawEmploymentData %>%
filter(!STATEFIP %in% c("037", "51000"))
n_distinct(employmentData1$STATEFIP)
# Aggregate monthly unemployment rates into annual
annualEmploymentData <- employmentData1 %>%
group_by(STATEFIP, STATE, YEAR) %>%
summarise(
UNEMPLOYMENTRATE = mean(UNEMPLOYMENTRATE, na.rm = TRUE),
) %>%
ungroup()
head(annualEmploymentData)
colSums(is.na(annualEmploymentData))
##### Female Median Weekly Wages #####
# Import data
rawFemaleWage <- read_csv("../data/cps_00006.csv", show_col_types = FALSE)
head(rawFemaleWage)
colSums(is.na(rawFemaleWage))
# Filter only for working women, avoiding case where number of hours worked = 0, but wage not 0 etc
rawFemaleWage1 <- rawFemaleWage %>%
filter(WKSWORK1 > 0, INCWAGE > 0)
# Compute median wage for each state-year, weighted by ASECWT
medianWage <- rawFemaleWage1 %>%
mutate(weekly_wage = INCWAGE / WKSWORK1) %>%
group_by(STATEFIP, YEAR) %>%
summarise(
median_weekly_wage = wtd.quantile(weekly_wage, weights = ASECWT, probs = 0.5, na.rm = T)
)
head(medianWage)
# Import libraries
library(tidyverse)
library(lubridate)
library(readxl)
library(Hmisc) # this one is for computing weighted median wages
##### Unemployment rate #####
# Import data
rawEmploymentData <- read_excel("../data/ststdnsadata.xlsx",
range = "A9:K31596",
col_names = c("STATEFIP", "STATE", "YEAR", "MONTH", "CNIP", "LABORFORCE", "PCT", "EMPLOYED", "EMPLOYMENTRATE", "UNEMPLOYED", "UNEMPLOYMENTRATE")
)
head(rawEmploymentData)
n_distinct(rawEmploymentData$STATEFIP)
unique(rawEmploymentData$STATEFIP)
# Keep only states
employmentData1 <- rawEmploymentData %>%
filter(!STATEFIP %in% c("037", "51000"))
n_distinct(employmentData1$STATEFIP)
# Aggregate monthly unemployment rates into annual
annualEmploymentData <- employmentData1 %>%
group_by(STATEFIP, STATE, YEAR) %>%
summarise(
UNEMPLOYMENTRATE = mean(UNEMPLOYMENTRATE, na.rm = TRUE),
) %>%
ungroup()
head(annualEmploymentData)
colSums(is.na(annualEmploymentData))
##### Female Median Weekly Wages #####
# Import data
rawFemaleWage <- read_csv("../data/cps_00006.csv", show_col_types = FALSE)
head(rawFemaleWage)
colSums(is.na(rawFemaleWage))
# Filter only for working women, avoiding case where number of hours worked = 0, but wage not 0 etc
rawFemaleWage1 <- rawFemaleWage %>%
filter(WKSWORK1 > 0, INCWAGE > 0)
# Compute median wage for each state-year, weighted by ASECWT
medianWage <- rawFemaleWage1 %>%
mutate(weekly_wage = INCWAGE / WKSWORK1) %>%
group_by(STATEFIP, YEAR) %>%
summarise(
median_weekly_wage = wtd.quantile(weekly_wage, weights = ASECWT, probs = 0.5, na.rm = T)
)
head(medianWage)
# Save data
saveRDS(annualEmploymentData, "../cleaned_data/annualEmployment.rds")
saveRDS(medianWage, "../cleaned_data/medianWage.rds")
